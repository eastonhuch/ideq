% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dstm.R
\name{dstm_ide}
\alias{dstm_ide}
\title{Integrodifference equation (IDE) model}
\usage{
dstm_ide(Y, locs = NULL, knot_locs = NULL, proc_error = "IW",
  J = 3L, n_samples = 10L, sample_sigma2 = TRUE, verbose = FALSE,
  params = NULL)
}
\arguments{
\item{Y}{(numeric matrix) S by T data matrix containing response variable at S spatial
locations and T time points.
The t-th column (NOT row) corresponds to the t-th observation vector.}

\item{locs}{(numeric matrix)
S by 2 matrix containing the spatial locations of the observed data.
The rows of `locs` correspond with the rows of `Y`.}

\item{knot_locs}{(integer or numeric matrix) Knot locations for the spatially varying IDE model.
The kernel parameters are estimated at these locations and then mapped to the
spatial locations of the observed data via process convolution.
If an integer is provided, then the knots are located on an equally spaced
grid with dimension (`knot_locs`, `knot_locs`).
If a matrix is provided, 
then each row of the matrix corresponds to a knot location.
If NULL, then the standard (spatially constant) IDE is fit.}

\item{proc_error}{(character string) Process error:
"IW" (inverse-Wishart) or "Discount" (discount factor).}

\item{J}{(integer) Extent of the Fourier approximation.
The size of the state space is (2*J + 1)^2.}

\item{n_samples}{(integer) Number of posterior samples to draw.}

\item{sample_sigma2}{(logical) Whether to sample the variance of the iid observation error.}

\item{verbose}{(logical) Whether to print additional information;
e.g., iteration in sampling algorithm.}

\item{params}{(list) List of hyperparameter values; see details.}
}
\description{
dstm_ide fits a type of dynamic spatio-temporal model called
an integrodifference equation (IDE) model.
It estimates a redistribution kernel---a
probability distribution controlling diffusion across time and space.
Currently, only normal redistribution kernels are supported.

The process model is decomposed with an orthonormal basis function expansion
(a Fourier series).
It can then be estimated as a special case of a dynamic linear model (DLM),
using the forward filtering backward sampling algorithm to estimate the
state vector.
The kernel parameters are estimated with a random walk Metropolis-Hastings
update.
The other parameters are estimated with conditionally conjugate updates.
}
\details{
This section explains how to specify custom hyperparameters using the `params` argument.
For each distribution referenced below,
we use the scale parameterization found on the distribution's Wikipedia page.
You may specify the following as named elements of the `params` list:

m_0: (numeric vector) The prior mean of the state vector at time zero
 (\eqn{\theta_0}).

C_0: (numeric matrix) The prior variance-covariance matrix of the state
vector at time zero (\eqn{\theta_0}).

alpha_sigma2, beta_sigma2: (numeric scalars) The inverse-Gamma parameters 
(scale parameterization) of the prior distribution on the observation error 
(\eqn{\sigma^2}).

sigma2: (numeric scalar) The value to use for the observation error 
(\eqn{\sigma^2}) if sample_sigma2 = FALSE.

alpha_lambda, beta_lambda: (numeric scalars) The inverse-Gamma parameters 
(scale parameterization) of the prior distribution on 
\eqn{\lambda = (1 - \delta) / \delta},
where \eqn{\delta} is the discount factor.

scale_W: (numeric matrix) The scale matrix for the inverse-Wishart prior
distribution on the variance-covariance matrix of the process error (W).

df_W: (numeric scalar) The degees of freedom for the inverse-Wishart prior
distribution on the variance-covariance matrix of the process error (W).

L: (numeric scalar) The period of the Fourier series approximation.
The spatial locations and knot locations are rescaled
to range from -L/4 to L/4 because the Fourier decomposition assumes that
the spatial surface is periodic.

smoothing: (numeric scalar) Controls the degree of smoothing in the 

mean_mu_kernel: (numeric vector) The mean of the normal prior distribution
on mu_kernel, the mean of the redistribution kernel.
In the spatially varying case, the prior distribution for mu_kernel
is assumed to be the same at every knot location.

var_mu_kernel: (numeric matrix) The variance of the normal prior distribution
on mu_kernel, the mean of the redistribution kernel.

scale_Sigma_kernel: (numeric matrix) The scale matrix for the 
inverse-Wishart prior distribution on Sigma_kernel,
the variance-covariance matrix of the redistribution kernel.

df_Sigma_kernel: (numeric scalar) The degrees of freedom for the 
inverse-Wishart prior distribution on Sigma_kernel,
the variance-covariance matrix of the redistribution kernel.

proposal_factor_mu: (numeric scalar) Controls the variance of the proposal distribution for
mu. The proposals have a variance of proposal_factor_mu^2 * var_mu_kernel.
proposal_factor_mu must generally be set lower for spatially varying models.

proposal_factor_Sigma: (numeric scalar) Controls the variance of the proposal distribution
for Sigma. As is the case with proposal_factor_mu, a higher value
corresponds to a higher variance.
The degrees of freedom for the proposal distribution for Sigma is 
ncol(locs) + df_Sigma_kernel / proposal_factor_Sigma.
proposal_factor_Sigma must generally be set lower for spatially varying 
models.
}
\examples{
# Create example data
num_time_points <- 5
spatial_locations <- expand.grid(seq(10), seq(10))
num_spatial_locations <- nrow(spatial_locations)
z <- rnorm(num_time_points * num_spatial_locations)
Y <- matrix(z, nrow=num_spatial_locations, ncol=num_time_points)

# Basic IDE model with one kernel
mod <- dstm_ide(Y, spatial_locations)
predict(mod)
summary(mod)

# IDE model with spatially varying kernel
dstm_ide(Y, spatial_locations, knot_locs=4)

# Discount factor method for estimating process error variance
dstm_ide(Y, spatial_locations, proc_error="Discount")

# Fix sigma2
dstm_ide(Y, spatial_locations, sample_sigma2=FALSE, params=list(sigma2=1))

# Set prior on sigma2
dstm_ide(Y, spatial_locations, 
         params=list(alpha_sigma2=10, beta_sigma2=11))

# Rescale spatial locations to have range of 10
dstm_ide(Y, spatial_locations, params=list(L=10)) 

# Set prior on kernel mean
dstm_ide(Y, spatial_locations, 
         params=list(mean_mu_kernel=c(0.2, 0.4),
                     var_mu_kernel=diag(2))) 

# Set prior on kernel variance-covariance matrix
dstm_ide(Y, spatial_locations, 
         params=list(scale_Sigma_kernel=diag(2), df_Sigma_kernel=100))

# Set prior on state vector (Fourier basis coefficients)
dstm_ide(Y, spatial_locations, 
         params=list(m_0=rep(0.1, 33), C_0=diag(0.01, 33))) 

# Set prior on process error
dstm_ide(Y, spatial_locations, 
         params=list(scale_W=diag(33), df_W=100))

# Set proposal scaling factors
dstm_ide(Y, spatial_locations, 
         params=list(proposal_factor_mu=2,
                     proposal_factor_Sigma=3))
}
